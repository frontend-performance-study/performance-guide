# 올림픽 통계 서비스 최적화

<br>

### 쟁크 현상

- 애니메이션이 끊겨보이는 현상
- 무언가의 이유로 CPU가 다른 일을 하느라 바빠서 60FPS로 화면을 그리지 못하였기 때문.

<br>

무언가의 이유?
=> 브라우저의 렌더링 과정을 이해해야함

<br>

## 브라우저의 렌더링 과정

DOM + CSSOM > 렌더 트리 > 레이아웃 > 페인트 > 컴포지트

<br>

### 1. DOM + CSSOM

화면을 그려내는데 필요한 리소스들(HTML,CSS 등)을 다운로드 받고 파싱하여 트리구조를 만들어냄.

- HTML => DOM
- CSS => CSSOM

<br>

### 2. 렌더 트리

DOM + CSSOM의 결합으로 렌더트리를 생성

화면에 표시되는 각 요소의 레이아웃을 계산

<br>

```css
display: none;
```

- 렌더 트리에 포함되지 않음

```css
opacity: 0;

or

visibility: hidden;
```

- 렌더 트리에 포함됨.

<br>

### 3. 레이아웃

화면 구성 요소의 위치나 크기를 계산하고, 해당 위치에 요소를 배치

<br>

### 4. 페인트

화면에 배치된 요소에 색을 채워 넣는 작업

<br>

### 5. 컴포지트

각 레이어를 합성하는 단계

<br>

## 리플로우 & 리페인트

### 리플로우

- 화면의 구조가 바뀌어 주요 렌더링 경로의 모든 단계를 모두 재실행
- 모든 단계를 다시 거쳐야하는 만큼 브라우저의 리소스를 많이 사용하게됨.

### 리페인트

- 구조의 변경은 없이 색상 등이 변경되었을 때, 레이아웃을 건너뛴 렌더링 단계가 실행됨.
- 리플로우보다는 적은 브라우저의 리소스를 사용하지만, 이 또한 발생하면 성능에 좋지 못함.

<br>

### ‼️ 추가)

리플로우가 발생하면 필연적으로 리페인트가 발생하지만

리페인트가 발생한다고 리플로우가 발생하는 것은 아님.

<br>

## transform & opacity

- 리플로우와 리페인트를 피할 수 있는 방법

<br>

### 하드웨어 가속 (GPU 가속)

CPU에서 처리해야 할 작업을 성능이 좋은 GPU가 처리하여 더 효율적인 처리 효과를 냄.

transform, opacity가 이 GPU 가속을 이용할 수 있음.

<br>

## 컴포넌트 지연 로딩

lazy 로딩, Suspense를 사용해서 필요한 시점에 컴포넌트를 로딩할 수 있음.

하지만, 지연시키는거지 로딩할 시점 시에는 크기에 따라 약간의 지연이 발생할 수 있다는 단점이 있음.

이것을 개선하고자 `컴포넌트 사전 로딩` 방법을 쓰면 좋음

<br>

## 컴포넌트 사전 로딩

모듈이 필요해질 것이라 생각되는 시점에 미리 불러오는 방식

언제?

1. hover 되었을 때
2. 모든 컴포넌트가 마운트 되었을 때

<br>

### hover 되었을 때

`onMouseEnter` 메서드를 이용.

<br>

### 모든 컴포넌트가 마운트 되었을 때

클래스형 컴포넌트 => componentDidMount 시점
함수형 컴포넌트 => useEffect 시점

<br>

이 방법들 말고도 다양한 방법으로 사전 로드할 수 있음.

1. IntersectionObserver API 활용
2. link의 preload 활용

ex)

```html
<link rel="preload" href="./path/to/component.js" as="script" />
```

<br>
