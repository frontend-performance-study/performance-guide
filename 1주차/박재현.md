# Lighthouse 탭


## Mode

- Navigation: Lighthouse 기본값, 초기 페이지 로딩 시 성능 문제 파악
- Timespan: 사용자가 정의한 시간동안 발생한 성능 문제 분석
- Snapshot: 현재 상태 성능 문제 분석

## Categories

- Performance: 웹페이지 로딩 과정에서 발생하는 성능 문제 분석
- Accessibility: 서비스의 사용자 접근성 문제 분석
- Best Practices: 웹사이트의 보안 측면과 웹 개발의 최신 표주에 중점 두고 분석
- Progressive Web App: 서비스워커와 오프라인 동작 등, PWA와 관련된 문제 분석

# Web Vitals

## FCP(First Contentful Paint) - 10%

페이지가 로드될 때 브라우저가 DOM 컨텐츠의 첫번째 부분을 렌더링하는데까지 걸린 시간에 관한 지표

## SI (Speed Index) - 10%

페이지 로드 중 콘텐츠가 시각적으로 표시되는 속도

## LCP (Largest Contentful Paint) - 25%

페이지가 로드될 때 화면 내에 있는 가장 큰 이미지나 텍스트의 요소가 렌더링되기까지 걸린 시간

## TTI (Time to Interactive) - 10%

사용자가 페이지와 상호작용하기까지 걸린 시간

⇒ 이 시점 전까지 화면이 보이더라도 클릭같은 입력이 동작하지 않는다

## TBT(Total Blocking Time) - 30%

페이지가 클릭, 키보드 입력 등의 사용자 입력에 응답하지 않도록 차단된 시간을 총합한 지표

FCP와 TTI 사이의 시간동안 일어나며 메인 스레드를 독점하여 다른 동작을 방해하는 작업에 걸린 시간을 총합한 지표

## CLS(Cumulative Layout Shift) - 15%

페이지 로드 과정에서 발생하는 예기치 못한 레이아웃 이동을 측정

레이아웃 이동 ⇒ 요소의 위치나 크기가 순간적으로 변하는 것

Opportunities: 페이지를 더욱 빨리 로드하는 데 잠재적으로 도움되는 제안을 나열

Diagnostics: 로딩 성능과는 직접적인 관계는 없지만 성능과 관련된 기타정보

Emulated Desktop → CPU Throttling: CPU 성능 제한

- 1x가 기본이고 4x는 모바일

Custom Throttling → Network Throtting: 네트워크 성능을 제한해 어느 정도 고정된 네트워크 환경에서 성능 측정

위 두가지 제한 떄문에 Lighthouse 없이 그냥 페이지를 로드하는 속도보다 Lighthouse를 이용해 측정할 떄 페이지 로드 속도가 더 느림

# 이미지 사이즈 최적화

요즘 사용되는 레티나 디스플레이는 같은 공간 (픽셀)에 더 많은 픽셀을 그릴 수 있으므로 **너비 기준 두배 정도 큰 이미지** 사용하기

자체적으로 가지고 있는 정적이미지는 편집 툴을 사용하면 되지만, 

API를 통해 이미지를 가져오는 경우 Cloudinary나 Imagix 같은 **이미지 CDN** 사용

## 이미지 CDN

이미지 CDN은 일반 CDN의 특징 + 이미지 가공 기능(이미지 사이즈를 줄이거나 특정 포맷을 변환하는 기능)이 있다.

# Performance 탭 사용 방법

1. Lighthouse의 View Original Trace

Lighthouse로 분석한 내용을 Performance 탭으로 가져가서 보여준다

1. Performance 패널로 이동해서 분석

새로고침 버튼을 누르면 페이지가 로드되면서 그 과겆ㅇ에서의 여러 작업을 기록 (네트워크, 메인 스레드 등)

## CPU 차트

CPU가 어떤 작업을 하고 있는지 비율

JS: 노랑

렌더링/레이아웃: 보라

페인팅: 초록

기타 시스템: 회색

병목 발생: 빨강

## Network

진한 막대: 높은 네트워크 리소스

연한 막대: 우선순위 낮은 리소스

## 스크린샷

서비스 로드되는 과정

## Network Timeline

서비스 로드 과정에서의 네트워크 요청을 시간 순서에 따라 보여준다

- 왼쪽 회색선: 초기 연결 시간
- 막대의 옅은 색 영역: 요청을 보낸 시점부터
- 막대의 짙은 색 영역: 콘텐츠 다운로드 시간
- 오른쪽 회색선: 해당 요청에 대한 메인 스레드의 작업시간

## Frames

화면 변화가 있을 때마다 스크린 샷

## Timings

User Timing API를 통해 기록된 정보를 기록

막대들 ⇒ 리액트에서 각 컴포넌트의 렌더링 시간을 기록

## Main

브라우저의 메인 스레드에서 실행되는 작업을 플레임 차트로 보여줌

→ 어떤 작업이 오래 걸리는지 파악

## Summary

선택 영역에서 발생한 작업시간의 총합 + 비중

## Bottom-Up

가장 최하위에 있는 작업부터 상위 작업까지 역순으로 보여준다

## Call Tree 탭

Bottom up과 비슷한데 스택 대신 작업의 순서 및 의존성을 고려해 계층별로 보여준다

## Event log

발생한 이벤트 (loading, experience scripting, Rendering, Painting 등)

### **webpack-bundle-analyzer**

웹팩을 통해 번들링 된 파일이 어떤 코드, 어떤 라이브러리를 담고 있는지 보여줌

- 불필요한 코드 식별, 번들 파일에서의 코드 비중 식별
- 용량이 큰 외부 라이브러리가 어떤 컴포넌트에서만 특정적으로 사용되는지 확인 후 코드 스플리팅
- 경로 별 코드 스플리팅

# 코드 스플리팅

페이지 / 컴포넌트 별 코드를 분리하여 불필요한 코드를 로드하지 않도록 함

- 하나의 번들 파일을 여러 개의 파일로 쪼갤 수 있음
- 분할된 코드는 사용자가 서비스를 이용하는 중 해당 코드가 필요해지는 시점에 로드되어 실행
    - 이를 지연 로딩이라고 함

공통 모듈이 많고 그 모듈의 크기가 큰 경우엔 모듈 별로 코드 스플리팅을 할 수 있다. **핵심은 불필요한 코드 없이, 코드 중복 없이 적절한 사이즈의 코드를 적절한 타이밍에 로드하는 것이다.**

# 텍스트 압축

production 환경과 development 환경의 가장 큰 차이는 난독화와 경량화 등 추가 최적화 작업을 하는 것이다.

<aside>
💡 텍스트 압축이란?

텍스트 기반 압축 알고리즘을 적용하여 리소스 전송을 빠르게

인기 있는 알고리즘은 Gzip과 Deflate가 있지만 주로 Gzip을 쓴다

</aside>

텍스트 압축은 어떤 웹 서버를 사용하느냐에 따라 다름. 실습 기준은 serve 라이브러리 사용 시 기준임

vercel, nginx, netlify 등의 웹 서버 마다 다른 설정 방법이 존재함.