  * [캐시 최적화](#캐시-최적화)
    + [Cache-Control](#cache-control)
    + [적절한 캐시 유효시간](#적절한-캐시-유효시간)
  * [불필요한 CSS 제거](#불필요한-CSS-제거)
    + [Purge CSS](#purge-css)
- [4장 이미지 갤러리 최적화](#4장-이미지-갤러리-최적화)
  - [레이아웃 이동 피하기](#레이아웃-이동-피하기)
    - [레이아웃 이동의 원인](#레이아웃-이동의-원인)
    - [레이아웃 이동 해결](#레이아웃-이동-해결)
  - [이미지 지연 로딩](#이미지-지연-로딩)
  - [리덕스 렌더링 최적화](#리덕스-렌더링-최적화)
    - [Profiler API](#profiler-api)
  - [병목 코드 최적화](#병목-코드-최적화)
    - [getAverageColorOfImage 함수 분석](#getaveragecolorofimage-함수-분석)
    - [double tilde](#double-tilde)

## 캐시 최적화

> 캐시란 자주 사용하는 데이터나 값을 미리 복사해 둔 임시 저장 공간 또는 저장하는 동작이다
> 

웹에서 사용하는 캐시의 종류

- 메모리 캐시: 메모리(RAM)에 저장하는 방식
- 디스크 캐시: 파일 형태로 디스크에 저장하는 방식

개발자 도구를 열어 Network 패널을 확인해 보면 Size 항목에 memory cache 또는 disk cache로 되어있다.

캐시를 확인하기 위해선, Network 패널에 disable cache 설정을 꺼야 한다

구글에서 단순 새로고침 후 확인하면 메모리 캐시가 많다

→ 구글의 리소스가 메모리에 캐시되었기 때문이다

브라우저를 완전히 종료한 후 구글에 접속하는 첫 네트워크 리소스를 확인하면 디스크 캐시가 많다

→ 브라우저가 완전히 종료되면 메모리에 있는 내용은 제거하고 다음 접속 때는 파일 형태로 남아있는 캐시를 활용한다

### Cache-Control

- no-cache: 캐시를 사용하기 전 서버에 검사 후 사용
- no-store: 캐시를 사용 안함
- public: 모든 환경에서 캐시 사용 가능 (기본 값)
- private: 브라우저 환경에서만 캐시 사용가능하다. 외부 캐시 서버에서는 사용이 불가하다
- max-age: 캐시의 유효기간 (단위: 초)

public과 private는 max-age에서 설정한 시간만큼은 서버에서 사용 가능 여부를 묻지 않고 캐시된 리소스를 바로 사용. 만약 유효시간(max-age에서 설정한 시간)이 지나면 서버에 캐시된 리소스를 사용해도 되는지 다시 체크하고 유효 시간만큼 더 사용

예시)

- Cache-Control: max-age=60
    - 60초 동안 캐시를 사용. public 옵션이 없으므로 기본 값인 public으로 설정되어 모든 환경에서 캐시
- Cache-Control: private, max-age=60
    - 브라우저 환경에서만 600초 동안 캐시를 사용
- Cache-Control: public, max-age=0
    - 모든 환경에서 0초 동안 캐시를 사용. 0초는 사실상 캐시가 바로 만료되는 상태이므로 매번 서버에 캐시를 사용해도 되는지 확인 ⇒ 즉, no-cache와 동일한 설정

응답 헤더는 서버에서 설정하므로 서버 코드의 server.js에 구현해야 한다

→ 캐시 설정: Cache-Control에 max-age=10을 설정

→ 네트워크 탭에 Size에서 memory cache되었다가 10초 지나면 서버에서 리소스의 변경 여부를 확인

→ 여기서는 변경되지 않아서 그대로 사용 → 304 코드 사용

→ Size가 260KB로 기록된 이유는 캐시를 사용해도 되는지 확인하기 위해 네트워크 요청을 보내고 응답받았기 때문

Q. 캐시된 리소스와 서버의 최신 리소가 같은지 다른지 어떻게 확인할까?

→ 서버에서 캐시된 리소스의 응답 해더에 있는 Etag 값과 서버에 있는 최신 리소스의 Etag 값을 비교하여 캐시된 리소스가 최신인지 판단

→ 만약 서버에 있는 리소스가 변했다면 Etag 값이 달라지고, 서버는 새로운 Etag 값과 함께 최신 리소스를 브라우저로 다시 보내준다.

재검증 결과 브라우저가 가지고 있는 캐시가 유효하다면, 서버는 [304 Not Modified] 요청을 내려준다. 이 응답은 HTTP 본문을 포함하지 않기 때문에 매우 빠르게 내려받을 수 있다.

캐시의 재검증 요청 헤더 대표적인 것 2가지

1. If-None-Match: 캐시된 리소스의 Etag 값과 현재 리소스의 Etag 값이 같은지 확인
2. If-Modified-Since: 캐시된 리소스의 Last-Modified 값 이후에 서버 리소스가 수정되었는지 확인

재검증 결과 캐시가 유효하지 않으면, 서버는 [200 OK] 또는 적합한 상태 코드를 본문과 함께 내려준다. 추가로 HTTP 요청을 보낼 필요 없이 바로 최신 값을 내려 받을 수 있기 때문에 매우 효율적이다.

### 적절한 캐시 유효시간

리소스마다 사용이나 변경 빈도가 달라 캐시의 유효시간도 달라진다.

- HTML: 항상 최신 버전의 웹 서비스를 제공하기 위해 no-cache 설정.
    - 항상 최신 버전의 리소스를 제공하면서도 변경 사항이 없을 때만 캐시를 사용하기 위해서
- JS,CSS: public, max-age = 31536000 (1년)
    - 빌드된 자바스크립트와 CSS 파일은 파일명에 해시를 함께 가지고 있다. (main.bb8aac28.chunk.js). 코드가 변경되면 해시도 변경되어 완전히 다른 파일이 된다
    - 캐시를 아무리 오래 적용해도 HTML만 최신 상태라면 자바스크립트나 CSS 파일은 당연히 최신 리소슬를 로드한다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa066aaf-9963-4fca-b4d4-e45903492786/Untitled.png)

path.endsWith 메서드를 이용해 파일의 종류를 구분하여 캐시를 적용

## 불필요한 CSS 제거

Coverage 패널에서 페이지에서 사용하는 자바스크립트 및 CSS 리소스에서 실제 실행하는 코드가 얼마나 되는지 알려주며 그 비율을 표시한다

- Unused Bytes
- Usage Visualization
    - 파란 막대는 해당 코드가 실행되어 적용됨
    - 빨간 막대는 실행되지 않았음
- JS 코드의 커버리지는 어느 정도 감안을 해야 한다
    - Coverage 패널의 기록이 진행 중인 상태에서 페이지를 이동하고 기타 동작들을 해보면 점점 코드 사용 비율이 증가함
    - if 문 조건이 걸려있어 특정 동작에 의해 동작하는 경우가 있음
    - CSS 코드도 마찬가지로 페이지에 따라 아직 표시되지 않은 요소들이 있기 때문에 처음부터 모든 CSS 코드가 동작하지 않는다

### Purge CSS

파일에 들어있는 모든 키워들르 추출하여 해당 키워드를 이름으로 갖는 CSS 클래스만 보존하고 나머지 매칭되지 않은 클래스는 모두 지우는 방식으로 CSS 파일을 최적화

```jsx
// purge.config.js
module.exports = {
  defaultExtractor: (content) => content.match(/[\w\:\-]+/g) || []
}
```

Purge CSS가 텍스트 키워드를 추출할 때 콜론 문자를 하나의 키워드로 인식하지 못하고 잘라버리기 때문에 생기는 현상을 막기 위해

```jsx
"purge": "purgecss --css ./build/static/css/*.css --output ./build/static/css/ --content ./build/index.html ./build/static/js"
```

static에 있는 css 파일(--output 뒤)을 다른 파일과 비교(--content)하겠다는 뜻!
package.json의 script에 작성

# 4장 이미지 갤러리 최적화

## 레이아웃 이동 피하기

Lighthouse에서는 웹 페이지에서 레이아웃 이동이 얼마나 발생하는지를 나타내는 지표로 CLS라는 항목을 두고 성능 점수에 포함

- 0부터 1사이의 값을 가지며, 레이아웃 이동이 전혀 발생하지 않은 상태를 0, 그 반대를 1로 계산한다
- 권장하는 점수는 0.1 이하
- Performance 패널의 Experience 섹션을 보면 Layout Shift라는 빨간 막대를 확인 가능

### 레이아웃 이동의 원인

- 사이즈가 미리 정의되지 않은 이미지 요소
- 사이즈가 미리 정의되지 않은 광고 요소
- 동적으로 삽입된 콘텐츠
- 웹 폰트 (FOIT, FOUT)

### 레이아웃 이동 해결

해당 요소의 사이즈를 미리 예측할 수 있게 하기

1. padding을 이용하여 박스를 만든 뒤, 그 안에 이미지를 absolute로 띄우기
2. aspect-ratio라는 CSS 이미지 속성 사용하기

padding을 이용하여 비율을 맞출 수 있지만, padding의 퍼센트를 매번 계산해야 하고 코드가 직관적이지 않다

→ 두번째 방법을 추천


## 이미지 지연 로딩

3장과 달리 react-lazyload라는 라이브러리를 이용!

→ 스크롤을 내려 이미지가 화면에 들어올 때 이미지를 로드하므로 조금의 시간 지연 발생!

→ offset이라는 옵션을 이용해 특정 픽셀 이전에 미리 로드할지 설정

## 리덕스 렌더링 최적화

React Developer Tools를 이용하여 렌더링 측정

- Componenets: 리액트의 컴포넌트를 계층 구조로 탐색
- Profiler: 리액트의 렌더링이 어느 시점에 일어났는지 분석

이미지를 클릭해서 이미지 모달을 띄웠을 때, 모달만 렌더링되지 않고 모달과 전혀 상관없는 헤더와 이미지 리스트 컴포넌트까지 리렌더링된다

- 이 현상은 모달을 띄우는 순간, 모달의 이미지가 로드된 후 배경 색이 바뀌는 순간, 그리고 모달을 닫는 순간 발생
- 상식적으로 모달을 클릭했을 때 변경된 상태는 모달에 관련된 상태이지, category나 photos 상태가 아니다

서로 관련이 없는 상태인데도 왜 리렌더링될까?

- useSelector의 동작 방식과 관련 있다
    - 반환 값이 이전 값과 같다면 컴포넌트는 리덕스 상태 변화에 영향이 없다고 판단하여 리렌더링을 하지 않고, 반환 값이 이전 값과 다르면 영향이 있다고 판단해 리렌더링을 한다

```jsx
const { category, allPhotos, loading } = useSelector(
    state => ({
      category: state.category.category,
      loading: state.photos.loading,
      photos : state.category.category === 'all' ?  state.photos.data :  state.photos.data.filter(photo => photo.category === category);
    })
  );
```

- 객체를 새로 만듦 → 새로운 참조 값을 반환하므로 리덕스를 통해 구독한 값이 변했다고 판단
    - 객체를 새로 만들지 않도록 반환 값을 나눈다
    - sahllowEqual 메서드를 통해 얕은 비교를 한다
- 객체 안에서 filter 메서드를 통해 신규 객체를 만듦
    - useSelector 밖에서 필터링

### Profiler API

책에서는 플러그인을 통해 Profiler를 사용했지만 Profiler API를 React 코드 내에 추가해서 트리의 특정 부분의 렌더링 비용을 계산할 수 있다!

- id와 onRender의 props를 같이 사용해 주어야 한다
- **`id`**는 측정 중인 UI 부분을 식별하는 문자열이다.
- **`onRender`**은 프로파일 중인 트리의 컴포넌트가 업데이트될 때마다 React가 호출하는 콜백함수이다. 렌더링된 내용과 소요된 시간에 대한 정보를 수신한다.
    - **`id`** : 프로파일하는 react 트리를 식별하는 id. 위의 코드 예시로 id는 "App"이다.
    - **`phase`** : "mount", "update", "nested-update" 중 트리의 상태 정보를 수신한다. 여기서 update는 컴포넌트 자체의 업데이트를 뜻하며, nested-update는 부모 컴포넌트의 변경으로 업데이트된 경우를 뜻한다.
    - **`actualDuration`** : 프로파일하는 부분이 현재 업데이트를 하기 위해 쓴 렌더링 시간을 나타낸다. 이것은 서브트리에 대해 메모이제이션을 얼마나 잘했는지를 나타낸다. 초기 마운트 된 후 이 값이 크게 감소하는 것이 이상적이다.
    - **`baseDuration`** : 프로파일하는 부분이 최적화하지 않은 상태에서 전체를 다시 렌더링하는데 걸리는 시간을 예측한다. 이 값으로 렌더링에 가장 많은 비용을 드는 부분을 찾을 수 있다. actualDuration과의 비교를 통해 memoization이 잘 작동하는지 확인할 수 있다.
    - **`startTime`** : 업데이트 렌더링을 시작한 시점을 나타내는 숫자 타임 스탬프.
    - **`endTime`** : 현재 업데이트를 커밋한 시점을 나타낸 숫자 타임스탬프

```jsx
function Page() {
  const onRender: ProfilerOnRenderCallback = (
    id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime // ✅ onRender props에 넣을 콜백함수가 받는 인자
  ) => {
    console.log(
      `(${id})
      phase: ${phase}, 
      actualDuration: ${actualDuration}, 
      baseDuration: ${baseDuration}, 
      startTime: ${startTime} 
      commitTime: ${commitTime}`
    );
  };

  return (
    // ✅ Profiler가 필요한 props 두가지
    <Profiler id='App' onRender={onRender}>
      <App />
    </Profiler>
  );
}
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e63ed116-3154-4527-97ed-423794d1e1e4/Untitled.png)

이런 식으로 콘솔에서 확인 가능하다

**사용 시 주의할 점:** 기본적으로 프로덕션 빌드에서는 사용하지 않도록 설정되어있다. 프로덕션에서 사용할 경우 개발자 도구의 React Developer Tools의 Profiler 탭에서 분석 결과를 볼 수 없다.

## 병목 코드 최적화

이미지 모달을 띄웠을 때, 서비스가 느려진다

Performance 패널에서 기록을 하면, 이미지 로드된 후 Image Decode라는 작업이 실행됨을 알 수 있다

### getAverageColorOfImage 함수 분석

캔버스를 생성하고이미지를 그 안에 그린 뒤, 해당 캔버스에 구해 온 픽셀 값을 가져오고 모든 픽셀에 대해 평균값을 구하는 함수이다

하지만, 큰 이미지를 통째로 캔버스에 올리고, 반복문을 통해 가져온 픽셀 저볼르 하나하나 더하기 때문에 느리다.

1. 메모이제이션을 사용하기

한번 실행된 함수에 대해 반환값을 저장해 두었다가 똑같은 조건으로 실행되었을 때 함수의 코드를 모두 실행하지 않고 바로 저에 기억해 둔 값을 반환

⚠️ 주의!!: 동일한 조건에서 충분히 반복 실행될 때 사용하자

2. 함수 로직 개선

함수의 drawImage, getImageData 함수, 모든 픽셀에 대해 실행되는 반복문은 이미지 사이즈에 따라 작업량이 결정된다

원본 이미지로 배경 색을 계산하고 있지만 썸네일 이미지(더 작은 이미지)로 배경 색을 계산하게 한다면 작업량이 단축될 것이다.

→ 인자로 섬네일 이미지를 넘겨주기 위해 PhotoItem 컴포넌트에서 배경색을 계산

→ 이미지 클릭된 시점에서 계산하고 Imagemodal에서는 배경색을 설정하는 코드 삭제하기

### double tilde

- Math.floor() 대신 사용
    - 속도 측면: ~~ > Math.floor() > parseInt
- undefined 또는 null을 0으로 변환할 때 사용하기